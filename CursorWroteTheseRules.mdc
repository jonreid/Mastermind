---
description: 
globs: 
alwaysApply: false
---
# Swift Coding Style Guide

## Steve Kuo's Microobjects Philosophy

### Core Philosophy

#### Code Organization
- **Composition over Inheritance**: Prefer protocols and dependency injection over class hierarchies
- **Self-Documenting Code**: Write code that reads like prose - comments are either lies or apologies
- **Readability First**: Optimize for human understanding, optimize performance only when needed
- **Descriptive Naming**: Use long, descriptive names that clearly express intent and purpose
- **SmallTalk Microobjects**: Prefer very small, focused objects with single responsibilities
- **Extreme Encapsulation**: Objects protect their private data and answer questions rather than exposing internal state

#### Error Handling
- **Fail-Fast with Unchecked Exceptions**: Use `fatalError()` and custom errors for unrecoverable conditions
- **Fail Early**: Validate inputs and fail immediately when preconditions aren't met
- **No Silent Failures**: Always throw exceptions rather than returning nil or empty results

#### Testing Approach
- **Test-Driven Development**: Write tests first, then implement the minimal code to pass
- **Behavior-Driven Development**: Use descriptive test names that explain the behavior
- **Test Names as Documentation**: Test method names should read like specifications

#### Encapsulation Principles
- **Ask, Don't Tell**: Ask objects questions rather than extracting their data
- **Keep Logic with Data**: Business logic about an object's data belongs with that object
- **No Data Leakage**: Objects never expose their internal state through getters
- **Composed Responses**: Objects provide answers by composing their internal knowledge
- **Tell, Don't Ask**: Objects tell other objects what to do rather than being asked for data

### Swift-Specific Microobjects Implementation

#### Example: Before (Data Leakage)
```swift
// ❌ Bad: Exposing internal state
struct User {
    let name: String
    let age: Int
    let email: String
    
    // Data leakage - exposing internal state
    var isAdult: Bool {
        return age >= 18
    }
}

// ❌ Bad: Asking for data to make decisions
func processUser(user: User) {
    if user.isAdult {
        // Business logic scattered outside the object
        sendAdultNotification(user.email)
    } else {
        sendMinorNotification(user.email)
    }
}
```

#### Example: After (Microobjects with Encapsulation)
```swift
// ✅ Good: Encapsulated behavior with proper naming
struct User {
    private let name: String
    private let age: Int
    private let email: String
    
    init(name: String, age: Int, email: String) {
        self.name = name
        self.age = age
        self.email = email
    }
    
    // Noun: returns whether the user should receive adult notifications
    func shouldReceiveAdultNotifications() -> Bool {
        return age >= 18
    }
    
    // Verb: mutates the system state by sending appropriate notification
    func sendAppropriateNotification(notifier: NotificationService) {
        if shouldReceiveAdultNotifications() {
            notifier.sendAdultNotification(to: email)
        } else {
            notifier.sendMinorNotification(to: email)
        }
    }
}

// ✅ Good: Tell, don't ask
func processUser(user: User, notifier: NotificationService) {
    user.sendAppropriateNotification(notifier: notifier)
}
```

#### Microobjects in Swift
```swift
// Example: Very small, focused objects with proper naming
struct EmailAddress {
    private let value: String
    
    init(_ value: String) throws {
        guard isValidEmail(value) else {
            throw ValidationError.invalidEmail
        }
        self.value = value
    }
    
    // Verb: mutates the system state by sending notification
    func sendNotification(service: NotificationService) {
        service.send(to: value)
    }
    
    // Noun: returns the email as a string
    func stringValue() -> String {
        value  // Avoid return for single expressions
    }
}

struct Age {
    private let years: Int
    
    init(_ years: Int) throws {
        guard years >= 0 && years <= 150 else {
            throw ValidationError.invalidAge
        }
        self.years = years
    }
    
    // Noun: returns whether the age represents an adult
    func isAdult() -> Bool {
        years >= 18  // Avoid return for single expressions
    }
    
    // Noun: returns the number of years
    func years() -> Int {
        years  // Avoid return for single expressions
    }
}

struct User {
    private let name: String
    private let age: Age
    private let email: EmailAddress
    
    init(name: String, age: Age, email: EmailAddress) {
        self.name = name
        self.age = age
        self.email = email
    }
    
    // Verb: mutates the system state by handling notification
    func handleNotification(service: NotificationService) {
        if age.isAdult() {
            email.sendNotification(service: service)
        }
    }
    
    // Noun: returns the user's name
    func name() -> String {
        name  // Avoid return for single expressions
    }
}
```

#### Fail-Fast Error Handling in Swift
```swift
// Example: Fail-fast with custom errors
enum ValidationError: Error {
    case invalidEmail
    case invalidAge
    case invalidName
}

struct UserValidator {
    static func validateName(_ name: String) throws -> String {
        guard !name.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty else {
            throw ValidationError.invalidName
        }
        return name.trimmingCharacters(in: .whitespacesAndNewlines)
    }
    
    static func validateAge(_ age: Int) throws -> Int {
        guard age >= 0 && age <= 150 else {
            throw ValidationError.invalidAge
        }
        return age
    }
}

// Usage: Fail early
func createUser(name: String, age: Int, email: String) throws -> User {
    let validatedName = try UserValidator.validateName(name)
    let validatedAge = try UserValidator.validateAge(age)
    let validatedEmail = try EmailAddress(email)
    
    return User(
        name: validatedName,
        age: Age(validatedAge),
        email: validatedEmail
    )
}
```

#### Self-Documenting Code Examples
```swift
// ❌ Bad: Unclear intent
func process(data: [String]) -> [String] {
    data.filter { $0.count > 3 }.map { $0.uppercased() }  // Avoid return for single expressions
}

// ✅ Good: Self-documenting with descriptive names
func extractLongWordsAndCapitalize(_ words: [String]) -> [String] {
    let longWords = words.filter { word in
        word.count > 3
    }
    
    let capitalizedWords = longWords.map { word in
        word.uppercased()
    }
    
    capitalizedWords  // Avoid return for single expressions
}

// ✅ Better: Even more descriptive with extracted methods
func extractLongWordsAndCapitalize(_ words: [String]) -> [String] {
    let longWords = extractWordsLongerThanThreeCharacters(from: words)
    capitalizeAllWords(longWords)  // Avoid return for single expressions
}

private func extractWordsLongerThanThreeCharacters(from words: [String]) -> [String] {
    words.filter { $0.count > 3 }  // Avoid return for single expressions
}

private func capitalizeAllWords(_ words: [String]) -> [String] {
    words.map { $0.uppercased() }  // Avoid return for single expressions
}
```

### Integration with TDD and Swift Best Practices

#### Microobjects in TDD Cycle
```swift
// Step 1: Test the microobject behavior with domain language
func test_age_indicatesAdult_whenYearsIs18() throws {
    let sut = try! Age(18)
    XCTAssertTrue(sut.isAdult())
}

func test_age_indicatesMinor_whenYearsIs17() throws {
    let sut = try! Age(17)
    XCTAssertFalse(sut.isAdult())
}

// Step 2: Implement minimal microobject
struct Age {
    private let years: Int
    
    init(_ years: Int) throws {
        self.years = years
    }
    
    // Noun: returns whether the age represents an adult
    func isAdult() -> Bool {
        years >= 18  // Avoid return for single expressions
    }
}

// Step 3: Add validation test with domain language
func test_age_throwsError_whenYearsIsNegative() throws {
    XCTAssertThrowsError(try Age(-1))
}

// Step 4: Implement validation
struct Age {
    private let years: Int
    
    init(_ years: Int) throws {
        guard years >= 0 else {
            throw ValidationError.invalidAge
        }
        self.years = years
    }
    
    // Noun: returns whether the age represents an adult
    func isAdult() -> Bool {
        years >= 18  // Avoid return for single expressions
    }
}
```

#### Composition over Inheritance in Swift
```swift
// ✅ Good: Composition with protocols
protocol NotificationService {
    func send(to email: String)
}

protocol ValidationService {
    func validateEmail(_ email: String) throws
}

struct UserService {
    private let notificationService: NotificationService
    private let validationService: ValidationService
    
    init(notificationService: NotificationService, validationService: ValidationService) {
        self.notificationService = notificationService
        self.validationService = validationService
    }
    
    func processUser(_ user: User) {
        user.handleNotification(service: notificationService)
    }
}
```

---

## Common Suggestions

### Code Quality
- Use meaningful variable names that describe their purpose
- Keep functions small and focused on a single responsibility
- Prefer immutable values (`let`) over mutable ones (`var`)
- Use `guard` statements for early returns and validation
- Leverage Swift's type system to prevent runtime errors

### Swift Best Practices
- Use `map`, `filter`, `reduce` for functional programming patterns
- Prefer `switch` statements over multiple `if-else` chains
- Use `lazy` properties for expensive computations
- Leverage protocol extensions for shared functionality
- Use `@available` for API compatibility

#### Swift Preferences in Practice
```swift
// ✅ Good: Using if let shorthand
func processUser(_ user: User?) {
    if let user {  // Shorthand instead of if let user = user
        user.handleNotification(service: notificationService)
    }
}

// ✅ Good: Avoiding -er in type names
struct Cash {  // Good: simple, descriptive
    let amount: Decimal
    let currency: Currency
}

struct USDCash {  // Good: specific currency
    let amount: Decimal
}

// ❌ Bad: Using -er suffix
struct CashFormatter {  // Bad: -er suffix
    func format(_ amount: Decimal) -> String {
        // formatting logic
    }
}
```

#### Construction Builder Pattern for Test Data
```swift
// ✅ Good: Construction Builder for nested structs
struct UserBuilder {
    private var id: UserId = UserId("test-123")
    private var name: String = "Test User"
    private var email: EmailAddress = try! EmailAddress("test@example.com")
    private var age: Age = try! Age(25)
    private var preferences: UserPreferences = UserPreferencesBuilder().build()
    
    func id(_ id: UserId) -> Self {
        self.id = id
        return self
    }
    
    func name(_ name: String) -> Self {
        self.name = name
        return self
    }
    
    func email(_ email: EmailAddress) -> Self {
        self.email = email
        return self
    }
    
    func age(_ age: Age) -> Self {
        self.age = age
        return self
    }
    
    func preferences(_ preferences: UserPreferences) -> Self {
        self.preferences = preferences
        return self
    }
    
    func build() -> User {
        User(
            id: id,
            name: name,
            email: email,
            age: age,
            preferences: preferences
        )
    }
}

struct UserPreferencesBuilder {
    private var theme: Theme = .light
    private var notifications: Bool = true
    private var language: Language = .english
    
    func theme(_ theme: Theme) -> Self {
        self.theme = theme
        return self
    }
    
    func notifications(_ enabled: Bool) -> Self {
        self.notifications = enabled
        return self
    }
    
    func language(_ language: Language) -> Self {
        self.language = language
        return self
    }
    
    func build() -> UserPreferences {
        UserPreferences(
            theme: theme,
            notifications: notifications,
            language: language
        )
    }
}

// Usage in tests
func test_user_hasCorrectPreferences() throws {
    let sut = UserBuilder()
        .name("John Doe")
        .age(try! Age(30))
        .preferences(
            UserPreferencesBuilder()
                .theme(.dark)
                .notifications(false)
                .build()
        )
        .build()
    
    XCTAssertEqual(sut.name(), "John Doe")
    XCTAssertEqual(sut.age().years(), 30)
    XCTAssertEqual(sut.preferences.theme, .dark)
    XCTAssertFalse(sut.preferences.notifications)
}
```

### Testing Best Practices
- Write tests that describe behavior, not implementation
- Use descriptive test names that read like specifications
- Test edge cases and error conditions
- Keep tests independent and isolated
- Use setup/teardown methods for common test data

### Error Handling
- Create specific error types for different failure scenarios
- Use `do-catch` blocks for comprehensive error handling
- Consider using `Result` types for operations that can fail
- Provide meaningful error messages for debugging

---

## Advanced Suggestions for Growth

### Architecture Patterns
- **Clean Architecture**: Separate concerns into layers (Domain, Use Cases, Presentation)
- **SOLID Principles**: Apply Single Responsibility, Open/Closed, Liskov Substitution, Interface Segregation, Dependency Inversion
- **Composition over Inheritance**: Use protocols and composition for flexibility
- **Repository Pattern**: Abstract data access behind protocols

### Swift Advanced Features
- **Property Wrappers**: Create custom property wrappers for common patterns
- **Result Builders**: Use for DSL-like APIs (like SwiftUI's ViewBuilder)
- **Key Paths**: Use for type-safe property access and transformations
- **Combine Framework**: For reactive programming and data flow
- **Concurrency**: Use async/await for modern asynchronous code

### Performance Optimization
- **Value Semantics**: Understand when to use structs vs classes
- **Copy-on-Write**: Implement for custom value types
- **Memory Management**: Use Instruments to profile memory usage
- **Algorithm Complexity**: Choose appropriate data structures and algorithms

### Testing Advanced Patterns
- **Property-Based Testing**: Use frameworks like SwiftCheck for generative testing
- **Integration Testing**: Test complete workflows and system interactions
- **Performance Testing**: Measure and track performance regressions

### Code Organization
- **Feature-Based Structure**: Organize by features rather than technical layers
- **Dependency Injection**: Use protocols for testability and flexibility
- **Modular Architecture**: Break large apps into modules/frameworks
- **API Design**: Design APIs that are easy to use correctly and hard to use incorrectly

### Swift Ecosystem
- **Package Manager**: Use Swift Package Manager for dependencies
- **Documentation**: Generate documentation with DocC
- **Linting**: Use SwiftLint for consistent code style
- **Continuous Integration**: Automate testing and code quality checks

### Advanced Swift Concepts
- **Generics**: Use for type-safe, reusable code
- **Protocols with Associated Types**: For flexible, generic protocols
- **Opaque Types**: Use `some` and `any` for type abstraction
- **Macros**: Create compile-time code generation (Swift 5.9+)
- **Custom Operators**: Define operators for domain-specific operations

### Debugging and Profiling
- **LLDB**: Master command-line debugging
- **Instruments**: Profile performance, memory, and other metrics
- **Symbolication**: Understand crash reports and stack traces
- **Network Debugging**: Use tools like Charles Proxy or Network Link Conditioner

### Code Review Practices
- **Pair Programming**: Collaborate on complex problems
- **Code Reviews**: Focus on design, not just syntax
- **Refactoring**: Continuously improve code quality
- **Technical Debt**: Balance new features with code maintenance

---

## Tools and Resources

### Recommended Tools
- **Xcode**: Latest version for best Swift support
- **SwiftLint**: Code style enforcement
- **SwiftFormat**: Automatic code formatting
- **Instruments**: Performance profiling
- **Git**: Version control with meaningful commit messages

### Learning Resources
- **Swift.org**: Official documentation and guides
- **WWDC Sessions**: Apple's annual developer conference
- **Swift Forums**: Community discussions and Q&A
- **Open Source Projects**: Study well-written Swift codebases
- **Books**: "Swift Programming Language", "Advanced Swift"
- **Steve Kuo's Works**: Microobjects and SmallTalk-inspired design

### Community
- **Swift Evolution**: Follow language evolution proposals
- **Local Meetups**: Connect with other Swift developers
- **Open Source Contributions**: Contribute to Swift projects
- **Blogs and Podcasts**: Stay updated with Swift ecosystem

---

## Quick Reference

### Naming Conventions
```swift
// Variables and functions
let userName = "John"
func calculateTotal() -> Double

// Constants
let maxRetryCount = 3

// Types
struct UserProfile { }
class NetworkManager { }
enum NetworkError { }

// Test methods
func test_shouldReturnUser_whenValidIdProvided() { }
```

### Common Patterns
```swift
// Guard for early returns
guard let user = currentUser else {
    return
}

// Result type for operations that can fail
func fetchUser(id: String) -> Result<User, NetworkError>

// Protocol-oriented programming
protocol UserRepository {
    func getUser(id: String) async throws -> User
}

// Dependency injection
class UserService {
    private let repository: UserRepository
    
    init(repository: UserRepository) {
        self.repository = repository
    }
}
```

### Microobjects Quick Reference
- **Ask, Don't Tell**: `user.shouldReceiveAdultNotifications()` not `user.age >= 18`
- **Tell, Don't Ask**: `user.sendAppropriateNotification(service)` not `if user.isAdult { service.send() }`
- **Fail Fast**: Validate inputs immediately, throw errors for invalid state
- **Self-Documenting**: Code should read like prose, avoid comments
- **Function Naming**: 
  - Nouns for functions that return something: `totalAmount()`, `isAdult()`
  - Verbs for functions that mutate: `processPayment()`, `confirm()`

### Domain-Driven Design Quick Reference
- **Ubiquitous Language**: Use domain terms consistently across code and tests
- **Value Objects**: Immutable objects representing domain concepts
- **Entities**: Objects with identity that can change over time
- **Domain Services**: Operations spanning multiple entities
- **Test Names**: Express domain concepts, avoid programming terms

### Modern Swift Quick Reference
- **Async/Await**: Use `async throws` → Result types → custom errors
- **Concurrency**: Prefer actors, then structured concurrency
- **Property Wrappers**: Create custom wrappers for common patterns
- **Result Builders**: Use for DSL-like APIs
- **Testing**: Swift Testing for domain logic, XCTest + ViewInspector for SwiftUI
- **Test Data**: Use Construction Builder pattern for nested structs
- **Test Variables**: Use `sut` for system under test
- **Classes**: Declare classes `final` unless they need subclassing

Remember: This guide should evolve with your experience and the Swift ecosystem. Regularly review and update your practices based on new learnings and project requirements.
